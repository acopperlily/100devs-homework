// A coloured triangle is created from a row of colours, each of which is red, green or blue. Successive rows, each containing one fewer colour than the last, are generated by considering the two touching colours in the previous row. If these colours are identical, the same colour is used in the new row. If they are different, the missing colour is used in the new row. This is continued until the final row, with only a single colour, is generated.

// The different possibilities are:

// Colour here:        G G        B G        R G        B R
// Becomes colour:      G          R          B          G
// With a bigger example:

// R R G B R G B B
//  R B R G B R B
//   G G B R G G
//    G R G B G
//     B B R R
//      B G R
//       R B
//        G
// You will be given the first row of the triangle as a string and its your job to return the final colour which would appear in the bottom row as a string. In the case of the example above, you would the given RRGBRGBB you should return G.

// The input string will only contain the uppercase letters R, G, B and there will be at least one letter so you do not have to test for invalid input.
// If you are only given one colour as the input, return that colour.

/* PREP
  Parameters: row - a string of letters 'R', 'B', and/or 'G'
  Returns: a single letter representing the color at the bottom of the "triangle"
  Examples: 
    'GB' returns 'R'
    'RBGB' returns 'B'
  Pseudocode:
    initialize empty string
    initialize array with first letter of string
    loop throw row
      push second letter of row into array
      compare current letter to next letter
        if same, concatenate string with letter
      use array includes method to find missing letter
        concatenate string with missing letter
      remove first letter from array
    update row with new concatenated string
    if length of new string is one, return the letter
    else, repeat above in while loop or recursive function call
*/

// function triangle(row) {
//   let current = row;
//   let next;
//   let arr;
//   while (current.length > 1) {
//     next = '';
//     arr = [current[0]];
//     for (let i = 0; i < current.length - 1; i++) {
//       arr.push(current[i+1]);
//       if (current[i] === current[i + 1]) {
//         next += current[i];
//       } else if (!arr.includes('R')) {
//         next += 'R';
//       } else if (!arr.includes('G')) {
//         next += 'G';
//       } else if (!arr.includes('B')) {
//         next += 'B';
//       }
//       arr.shift();
//     }
//     current = next;
//   }
//   return current;
// }

const triangle = row => {
  let next = '';
  let arr = [row[0]];
  for (let i = 0; i < row.length - 1; i++) {
    arr.push(row[i+1]);
    if (row[i] === row[i+1]) next += row[i];
    else if (!arr.includes('R')) next += 'R';
    else if (!arr.includes('B')) next += 'B';
    else if (!arr.includes('G')) next += 'G';
    arr.shift();
  }
  return row.length > 1 ? triangle(next) : row;
};

// Test cases
['GB', 'RRR', 'RGBG', 'RBRGBRB', 'RBRGBRBGGRRRBGBBBGG', 'B'].forEach(s => console.log(triangle(s)));
